#!/bin/bash

__Author="Jerren Saunders"
__Version=24.10.7.1312
__ScriptName=$(basename "$0") # File name with extension
__AppDir=$(dirname "$0") # Path where script is stored
__AppName=${__ScriptName%.*} # File name without extension
__origArgs=$* # Capture all of the original arguments

function print_usage() {
    includeAppInfo=${1}
    cat <<EOT

This script will search the current directory tree for a file named '${MY_CUSTOM_FILE}', containing 
a key that matches the first argument.  If found, the value of that key will be used instead.
This can be used to allow local overriding of certain commands to point to a container
instead of the local installed command.

USAGE:
    ${__ScriptName} [-OPTIONS] [help | version | add | COMMAND [args...]]
        add <cmd> <value>    Adds the 'cmd' to the ${MY_CUSTOM_FILE} file in the current directory.
                             This command should be run in the workspace root directory.
                             The given command will be used whenever called from this level or a descendant.
        
        <COMMAND> [...args]  The command to run
        
        help        Show usage
        version     Show version number

    OPTIONS:
        -v      Verbose Level (Multiple may be given to increase the verbosity)
        -d      Dry Run.


EOT
    if [[ ${includeAppInfo} ]]; then 
        cat <<EOT
 By: ${__Author}
 Version: ${__Version}

EOT
    fi

    # Print options values if verbose mode
    log 1 "Parsed Options:"
    log 1 "  DryRun:  ${DRYRUN}"
    log 1 "  Verbose: ${VERBOSE}"
    log 1 "  File:    ${MY_CUSTOM_FILE}"
    log 1 ""

}

# Default Settings
VERBOSE=0
DRYRUN=false
MY_CUSTOM_FILE=.myCommand

while getopts 'dv' option; do
    # echo "Option: ${option}"
    case ${option} in 
        d ) DRYRUN=true ;;
        v ) VERBOSE=$((VERBOSE + 1)) ;;
        * ) # Do Nothing
    esac
done
shift $((OPTIND -1)) # Remaining args will be left

# Prints log message to the terminal
#  <int> lvl - Print Level: Only print this message if the VERSBOSE level is greater than or equal to this
#  <string> msg - Message to print
function log() {
    local lvl=$1
    local msg=$2

    if (( lvl <= VERBOSE )); then
        echo -e "$msg"
    fi
}

# Either runs the command or prints the command that would be executed if DRYRUN is 'true'
#  <cmd> cmd - Command to execute or print
function runCMD() {
    local cmd="$*"

    if [[ "${DRYRUN}" == "true" ]]; then 
        log 0 "CMD: ${cmd}"
    else 
        eval "${cmd}"
    fi
}

# Adds a new key-value pair to the ${MY_CUSTOM_FILE} file in the current directory
#  <string> key - The key to add
#  <string> value - The value to associate with the key
function add_key_value() {
    local key=$1
    local value="${*:2}"  # Capture all remaining arguments as the value
    local my_version_file=${MY_CUSTOM_FILE}

    # Check if the ${MY_CUSTOM_FILE} file exists, create it if not
    if [ ! -f "$my_version_file" ]; then
        log 1 "The ${MY_CUSTOM_FILE} file does not exist. Creating a new one."
        touch "$my_version_file"
    fi

    # Check if the key already exists in the file
    if grep -q "^$key=" "$my_version_file"; then
        log 1 "The key '$key' already exists. Updating the value."
        # Use sed to update the existing key's value
        sed -i "s|^$key=.*|$key=$value|" "$my_version_file"
    else
        log 1 "Adding new key '$key' with value '$value'."
        # Add the new key-value pair to the file
        echo "$key=$value" >> "$my_version_file"
    fi

    log 2 "Updated .myVersion content:"
    log 2 "$(cat $my_version_file)"
    log 2
}


function main() {
    # The command to search for
    cmd=$1

    # Check for command line args
    case "$1" in
        help)
            print_usage true
            exit 0
            ;;

        version)
            echo "${__Version}"
            exit 0
            ;;

        add)
            if [[ -z "$2" || -z "$3" ]]; then
                log 1 "Usage: ${__ScriptName} add <key> <value>"
                exit 1
            fi
            add_key_value "$2" "$3"
            exit 0
            ;;

        *)
            if [[ "${DRYRUN}" == "true" ]]; then echo "---- THIS IS A DRYRUN! ----"; fi

            # Shift the arguments so that $@ does not include the first argument (the command)
            shift

            # Start in the current directory and move up the directory tree
            dir=$(pwd)
            while [ "$dir" != "/" ]; do
                # Check if the ${MY_CUSTOM_FILE} file exists in this directory
                if [ -f "$dir/${MY_CUSTOM_FILE}" ]; then
                    # Read the ${MY_CUSTOM_FILE} file and store the content
                    local -r my_version_content=$(<"$dir/${MY_CUSTOM_FILE}")

                    # Search for the key in the ${MY_CUSTOM_FILE} file
                    key_value=$(echo "$my_version_content" | grep "^$cmd=")
                    if [ -n "$key_value" ]; then
                        # Extract the command after the key
                        binary_cmd=$(echo "$key_value" | cut -d '=' -f2-)

                        # Replace any variables found in binary_cmd with their values
                        while [[ "$binary_cmd" =~ (\$[a-zA-Z_][a-zA-Z_0-9]*) ]]; do
                            var=${BASH_REMATCH[1]}
                            # Remove the leading $ from the variable name
                            var_name=${var:1}
                            # Get the value of the variable from my_version_content
                            var_value=$(echo "$my_version_content" | grep "^$var_name=" | cut -d '=' -f2-)
                            # Substitute the variable in the binary_cmd
                            binary_cmd=${binary_cmd//$var/$var_value}
                        done

                        log 1 "The command key '${cmd}' was found in '${dir}/${MY_CUSTOM_FILE}'"
                        log 2 "  with a value of '${binary_cmd}'"
                        log 1 ""

                        # Run the extracted command with the additional arguments
                        runCMD "$binary_cmd $*" 
                        exit $?
                    fi
                fi
                # Move up to the parent directory
                dir=$(dirname "$dir")
            done

            # If the key was not found in any ${MY_CUSTOM_FILE} file, run the default command
            log 1 "No ${MY_CUSTOM_FILE} file was found in the current directory tree\n"
            runCMD "$cmd $*"
            ;;
    esac
}

# Call main function and pass all (remaining) CL args
main "$@"
exit 0



######################################
###  Change History
######################################
# shellcheck disable=SC2317  # Don't warn about unreachable commands in this function
/dev/null <<EOT
 - 24.10.7.1312 Added command to add key to the .myCommand file
                Changed to using file ".myCommand" as default
 - 24.10.7.1216 Added ability to define variables within the .myVersion file that
                can be referenced and expanded in the key values
 - 24.10.7:     Initial Creation 
EOT